use crate::agents::{DecrLimits, DeleteSession, SaveAuthCode, SaveSession};
use crate::config::LimitInput;
use crate::crypto::{create_jwt, session_id};
use crate::email_address::EmailAddress;
use crate::error::{BrokerError, BrokerResult};
use crate::web::{
    json_response, return_to_relier, Context, HandlerResult, RequestData, ResponseType, Session,
    SessionData,
};
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::ops::Deref;
use std::sync::Arc;

/// Context object for bridges handling auth requests.
pub struct AuthContext {
    /// Request data, also accessible via `Deref`
    pub req: Arc<RequestData>,
    /// The email address being authenticated.
    pub email_addr: EmailAddress,
}

impl Deref for AuthContext {
    type Target = RequestData;
    fn deref(&self) -> &Self::Target {
        &self.req
    }
}

impl AuthContext {
    pub fn new(ctx: &Context, email_addr: EmailAddress) -> Self {
        AuthContext {
            req: ctx.req.clone(),
            email_addr,
        }
    }

    /// Try to save the session with the given bridge data.
    ///
    /// Will return `false` if another provider has already claimed the session.
    pub async fn save_session(&mut self, bridge_data: BridgeData) -> BrokerResult<bool> {
        let data = {
            let mut data = self.session_data.lock().expect("session mutex poisoned");
            let Some(data) = data.take() else {
                return Ok(false);
            };
            data
        };
        self.app
            .store
            .send(SaveSession {
                session_id: self.session_id.clone(),
                data: Session { data, bridge_data },
            })
            .await
            .map_err(|e| BrokerError::Internal(format!("could not save a session: {e}")))?;
        Ok(true)
    }
}

/// Session data stored by bridges.
#[derive(Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum BridgeData {
    Email(email::EmailBridgeData),
    Oidc(oidc::OidcBridgeData),
}

/// Once a bridge has authenticated the user, this function can be used to finish up the redirect
/// to the relying party with an `id_token` or `code` generated by us.
pub async fn complete_auth(ctx: &mut Context, data: SessionData) -> HandlerResult {
    ctx.app
        .store
        .send(DeleteSession {
            session_id: ctx.session_id.clone(),
        })
        .await
        .map_err(|e| BrokerError::Internal(format!("could not remove a session: {e}")))?;

    let origin = data
        .return_params
        .redirect_uri
        .origin()
        .ascii_serialization();

    ctx.app
        .store
        .send(DecrLimits {
            input: LimitInput {
                email_addr: data.email_addr.clone(),
                origin: origin.clone(),
                ip: data.original_ip,
            },
        })
        .await
        .map_err(|e| BrokerError::Internal(format!("could not decrement rate limits: {e}")))?;

    let (auth_field, auth_value) = match data.response_type {
        ResponseType::IdToken => {
            let jwt = create_jwt(
                &ctx.app,
                &data.email,
                &data.email_addr,
                &origin,
                data.nonce.as_deref(),
                data.signing_alg,
            )
            .await
            .map_err(|err| BrokerError::Internal(format!("Could not create a JWT: {err:?}")))?;
            ("id_token", jwt)
        }
        ResponseType::Code => {
            let code = session_id(&data.email_addr, &origin, &ctx.app.rng).await;
            ctx.app
                .store
                .send(SaveAuthCode {
                    code: code.clone(),
                    data,
                })
                .await
                .map_err(|e| BrokerError::Internal(format!("could not save auth code: {e}")))?;
            ("code", code)
        }
    };

    if ctx.want_json {
        Ok(json_response(&json!({
            auth_field: &auth_value,
            "state": &ctx.return_params.as_ref().unwrap().state,
        })))
    } else {
        Ok(return_to_relier(ctx, &[(auth_field, &auth_value)]))
    }
}

pub mod email;
pub mod oidc;
